{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Intro","text":"<p>This is an alternative logging module with extra capabilities. It provides a method to output various types of lines and headers, with customizable message and line lengths,  traces additional information and provides debug capabilities and optional persistence based on that. Its purpose is to be integrated into other classes that also use logger, primarily based on <code>attrsx</code>, including support for injecting any initialized logger.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install shouterlog\n</code></pre>"},{"location":"description/","title":"Description","text":"<pre><code>from shouterlog import Shouter\nimport logging\n</code></pre>"},{"location":"description/#1-initialize-shouter-class","title":"1. Initialize Shouter Class","text":"<p>Shouter is the core logging class in shouterlog\u2014a drop-in logger wrapper with richer formatting, traceback-aware records, and optional persistence/plotting hooks. Initialization lets you configure things like supported classes for readable tracebacks, formatting length/styles, whether to show function or traceback info, and paths for saving log records or environment snapshots.</p> <p>Common settings include <code>supported_classes</code>, <code>dotline_length</code>, <code>show_function</code>, <code>show_traceback</code>, <code>tears_persist_path</code>, and <code>persist_env</code>, but you can keep defaults and customize only what you need.</p>"},{"location":"description/#11-shouter-options-reference","title":"1.1 Shouter options (reference)","text":"<p>This table lists the main Shouter configuration fields and what they control. Fields managed by <code>attrsx</code> or handler setup are marked accordingly.</p> Option What it controls Notes <code>supported_classes</code> Tuple of classes Shouter should recognize when building readable tracebacks. Include classes you want shown in the call chain; if empty, it falls back to the immediate caller. <code>available_actions</code> List of <code>LogAction</code> items callable from logger methods via <code>actions=[...]</code>. <code>add_actions()</code> can append custom actions or built-ins like Langfuse. <code>dotline_length</code> Width for line/header styles (<code>line</code>, <code>dline</code>, <code>pline</code>, headers). Controls the visual length of separators and headers. <code>auto_output_type_selection</code> Whether output type is chosen automatically based on traceback depth. If <code>True</code> and <code>output_type</code> is <code>None</code>, Shouter picks a style. <code>show_function</code> Prefixes output with the current function/class name. Useful to keep basic context in each line. <code>show_traceback</code> Prefixes output with the traceback chain (leaf -&gt; root). When <code>False</code>, tracebacks are still recorded in tears. <code>show_idx</code> Whether to show the internal log index in output. Index is always stored in each tear. <code>tears_persist_path</code> File path for persisted JSON log records. Appended to on error/fatal/critical or <code>persist_state()</code>. <code>env_persist_path</code> File path for persisted environment snapshot. Written with <code>dill</code> when <code>persist_env=True</code>. <code>datetime_format</code> Timestamp format stored in each tear. Default is <code>%Y-%m-%d %H:%M:%S</code>. <code>persist_env</code> Enables writing a serializable locals snapshot on error/fatal/critical. Use for post-mortem debugging. <code>log_records</code> In-memory list of all tears captured so far. Internal; populated automatically. <code>lock</code> Thread lock used during persistence. Internal; created in <code>__attrs_post_init__</code>. <code>last_traceback</code> Storage for last traceback (legacy/local). Internal; ContextVars hold the active chain. <code>logger</code> The underlying <code>logging.Logger</code> instance. Provided by <code>attrsx</code> logger chaining; can be injected. <code>loggerLvl</code> Logger level used by attrsx logger setup. <code>attrsx</code>-managed; can be overridden via attrsx config. <code>logger_name</code> Logger name used by attrsx logger setup. <code>None</code> defaults to module/class naming. <code>logger_format</code> Log format string for the underlying logger. Defaults to <code>%(levelname)s:%(name)s:%(message)s</code>. <code>log_plotter_h</code> LogPlotter instance used for plotting. Initialized lazily by <code>show_sequence_diagram()</code>. <code>log_plotter_class</code> Class used to build the plotter handler. <code>attrsx</code> handler spec. <code>log_plotter_params</code> Parameters passed when constructing the plotter handler. <code>attrsx</code> handler spec. <code>langfuse_h</code> Langfuse handler instance for trace exporting. Only present if Langfuse is initialized. <code>langfuse_class</code> Class used to build the Langfuse handler. <code>attrsx</code> handler spec. <code>langfuse_params</code> Parameters passed when constructing Langfuse handler. <code>attrsx</code> handler spec. <pre><code>shouter = Shouter(\n    # optional/ required\n    supported_classes = (),\n    # optionally \n    ## Formatting settings\n    dotline_length = 50,\n    auto_output_type_selection = True,\n    show_function = False,\n    show_traceback = False,\n    # For saving records\n    tears_persist_path = 'log_records.json',\n    datetime_format = \"%Y-%m-%d %H:%M:%S\",\n    # For saving env\n    persist_env = False,\n    env_persist_path = 'environment.dill',\n    ## Logger settings\n    logger = None,\n    logger_name = 'Shouter',\n    loggerLvl = logging.DEBUG,\n    logger_format = '(%(asctime)s) : %(name)s : [%(levelname)s] : %(message)s'\n)\n\n</code></pre>"},{"location":"description/#2-basic-usage-like-logging","title":"2. Basic usage like logging","text":"<p>In basic usage, Shouter behaves like a standard Python logger, so calling <code>.info</code>, <code>.debug</code>, etc. produces familiar log output out of the box. You can then layer on extras (labels, output types, tracebacks) as needed.</p> <pre><code>shouter.debug(\n    # optional\n    dotline_length=30)\nshouter.debug(\"This is a debug message!\")\nshouter.info(\"This is an info message!\")\nshouter.warning(\"This is a warning message!\")\nshouter.error(\"This is an error message!\")\nshouter.fatal(\"This is a fatal message!\")\nshouter.critical(\"This is a critical message!\")\n</code></pre> <pre><code>(2026-01-28 00:38:47,911) : Shouter : [DEBUG] : ==============================\n(2026-01-28 00:38:47,914) : Shouter : [DEBUG] : This is a debug message!\n(2026-01-28 00:38:47,915) : Shouter : [INFO] : This is an info message!\n(2026-01-28 00:38:47,918) : Shouter : [WARNING] : This is a warning message!\n(2026-01-28 00:38:47,919) : Shouter : [ERROR] : This is an error message!\n(2026-01-28 00:38:47,921) : Shouter : [CRITICAL] : This is a fatal message!\n(2026-01-28 00:38:47,923) : Shouter : [CRITICAL] : This is a critical message!\n</code></pre>"},{"location":"description/#3-using-different-output-types","title":"3. Using different output types","text":"<p>Shouterlog supports multiple output types (lines, headers, titles, and warning styles) that change how the message is formatted. You can either set <code>output_type</code> explicitly for manual formatting, or leave it <code>None</code> and enable <code>auto_output_type_selection</code> so Shouter chooses a style based on the current traceback depth.</p> <p>Manual examples include <code>output_type='HEAD1'</code>, <code>output_type='line'</code>, or <code>output_type='subtitle2'</code>. Automatic formatting is useful when you want nested calls to visually indent/scale without specifying a format on every log.</p> <pre><code># Different types of outputs\nshouter.info(output_type=\"dline\")\nshouter.info(output_type=\"HEAD1\", mess=\"Header Message\")\n</code></pre> <pre><code>(2026-01-28 00:38:47,929) : Shouter : [INFO] : ==================================================\n(2026-01-28 00:38:47,931) : Shouter : [INFO] : \n==================================================\n-----------------Header Message----------------- \n==================================================\n</code></pre>"},{"location":"description/#4-custom-logger-configuration","title":"4. Custom logger configuration","text":"<p>Shouterlog is built with <code>attrsx</code>, so\u2014like other attrsx-based classes\u2014you can replace the built-in logger setup with any already-initialized <code>logging.Logger</code> instance. This lets you plug Shouter into existing logging configurations without changing your logger wiring.</p> <pre><code>import logging\n\n# Custom logger\ncustom_logger = logging.getLogger(\"CustomLogger\")\ncustom_logger.setLevel(logging.INFO)\n\n# Shouter with custom logger\nshouter_with_custom_logger = Shouter(supported_classes=(), logger=custom_logger)\nshouter_with_custom_logger.info(mess=\"Message with custom logger\")\n</code></pre>"},{"location":"description/#5-backwards-compatibility-with-existing-loggers","title":"5. Backwards compatibility with existing loggers","text":"<p>Backwards compatibility means Shouter keeps the standard logger method signatures (<code>.info</code>, <code>.debug</code>, etc.) while allowing extra keyword args for its custom features. When used inside <code>attrsx</code>, any extra parameters that the standard logger does not accept are treated as non-breaking and ignored, so integration does not change existing behavior.</p> <p>In practice, features like <code>save_vars</code>, <code>label</code>, or custom <code>output_type</code> only take effect when Shouter is active; otherwise they are safely dropped rather than raising errors.</p> <pre><code>import logging\nimport attrsx\n\n@attrsx.define\nclass ExampleClass:\n\n\n    def print_debug(self):\n\n        a = 0\n\n        self.logger.debug(\"This is a debug message!\", save_vars = [\"a\"])\n\n    def print_info(self):\n\n        self.logger.info(\"This is a info message!\")\n\n    def print_warning(self):\n\n        self.logger.warning(\"This is a warning message!\")\n\n    def print_error(self):\n\n        self.logger.error(\"This is a error message!\", label = \"TEST\")\n\n    def print_critical(self):\n\n        self.logger.critical(\"This is a critical message!\")\n\n    def perform_action_chain_1(self):\n\n        self.logger.debug(\"Action 1\")\n        self.print_debug()\n\n        self.logger.debug(\"Action 2\")\n        self.print_error()\n\n    def perform_action_chain_2(self):\n\n        a = 1\n        b = 'b'\n        c = ['list']\n        d = {'key' : 'value'}\n        e = Shouter()\n\n        self.logger.info(\"Logging vars\", save_vars = [\"a\",\"b\",\"e\"])\n        self.logger.error(\"Saving env\", label = \"TEST\")\n</code></pre> <pre><code>ec = ExampleClass()\n\nec.print_debug()\nec.print_info()\nec.print_warning()\nec.print_error()\nec.print_critical()\n</code></pre> <pre><code>INFO:ExampleClass:This is a info message!\nWARNING:ExampleClass:This is a warning message!\nERROR:ExampleClass:This is a error message!\nCRITICAL:ExampleClass:This is a critical message!\n</code></pre> <pre><code>shouter_for_example_class = Shouter(\n    supported_classes = (ExampleClass,),\n    tears_persist_path = 'log_records.json'\n)\n\nec = ExampleClass(logger=shouter_for_example_class)\n\nec.print_debug()\nec.print_info()\nec.print_warning()\nec.print_error()\nec.print_critical()\nec.perform_action_chain_1()\n</code></pre> <pre><code>INFO:Shouter:ExampleClass.print_info:This is a info message!\nWARNING:Shouter:ExampleClass.print_warning:This is a warning message!\nERROR:Shouter:ExampleClass.print_error:This is a error message!\nCRITICAL:Shouter:ExampleClass.print_critical:This is a critical message!\nERROR:Shouter:ExampleClass.print_error:+ This is a error message!\n</code></pre>"},{"location":"description/#6-built-in-records-from-shouter-usage","title":"6. Built-in records from Shouter usage","text":"<p>Each log call creates a built-in record (a \"tear\") that captures structured metadata: timestamp, level, function/traceback, line numbers, label, and optional environment data. These records accumulate in <code>Shouter.log_records</code> so you can inspect or export them later.</p> <p>You can access the full list with <code>Shouter.return_logged_tears()</code> or filter by id via <code>show_logs_by_id()</code>. The records are also the input for plotting and persistence features.</p> <pre><code>shouter_for_example_class = Shouter(\n    supported_classes = (ExampleClass,),\n    tears_persist_path = 'log_records.json'\n)\n\nec = ExampleClass(logger=shouter_for_example_class)\n\nec.print_debug()\nec.perform_action_chain_1()\n</code></pre> <pre><code>ERROR:Shouter:ExampleClass.print_error:+ This is a error message!\n</code></pre> <pre><code>import pandas as pd\n\npd.DataFrame(ec.logger.return_logged_tears())\n</code></pre> idx call_id datetime level function mess line lines is_proc proc_name traceback label env 0 1 140329803945952 2026-01-28 00:38:48 debug ExampleClass.print_debug This is a debug message! 12 [12] False Task-2 [ExampleClass.print_debug] None {'a': 0} 1 2 140329802125440 2026-01-28 00:38:48 debug ExampleClass.perform_action_chain_1 Action 1 32 [32] False Task-2 [ExampleClass.perform_action_chain_1] None {} 2 3 140329803946384 2026-01-28 00:38:48 debug ExampleClass.print_debug This is a debug message! 12 [12, 33] False Task-2 [ExampleClass.print_debug, ExampleClass.perfor... None {'a': 0} 3 4 140329802125440 2026-01-28 00:38:48 debug ExampleClass.perform_action_chain_1 Action 2 35 [35] False Task-2 [ExampleClass.perform_action_chain_1] None {} 4 5 104240188118496 2026-01-28 00:38:48 error ExampleClass.print_error This is a error message! 24 [24, 36] False Task-2 [ExampleClass.print_error, ExampleClass.perfor... TEST {}"},{"location":"description/#7-debugging-errors-with-shouter","title":"7. Debugging errors with Shouter","text":"<p>Debugging support has two persistence paths: (1) on <code>error</code>/<code>fatal</code>/<code>critical</code>, Shouter persists the log records and can dump a serializable snapshot of locals so you can inspect state even if the program breaks afterward; and (2) at any log level, <code>save_vars</code> lets you attach selected serializable locals directly to each log record (the \"tear\"), so they travel with the in-memory log list.</p> <p>Use <code>save_vars=[\"name\", \"obj.attr\"]</code> on any log call to store specific variables in the tear. For crash-time persistence, set <code>persist_env=True</code> (or call <code>persist_state()</code> manually) so the environment snapshot is dumped alongside the JSON log records.</p> <pre><code>shouter_for_example_class = Shouter(\n    supported_classes = (ExampleClass,),\n    tears_persist_path = 'log_records.json',\n    persist_env = True,\n    env_persist_path = 'environment.dill'\n)\n\nec = ExampleClass(logger=shouter_for_example_class)\n\nec.print_debug()\nec.perform_action_chain_2()\n</code></pre> <pre><code>INFO:Shouter:ExampleClass.perform_action_chain_2:Logging vars\nERROR:Shouter:ExampleClass.perform_action_chain_2:Saving env\n</code></pre> <pre><code>ec.logger.return_last_words(\n    # optional\n    env_persist_path = 'environment.dill'\n)\n</code></pre> <pre><code>{'a': 1,\n 'b': 'b',\n 'c': ['list'],\n 'd': {'key': 'value'},\n 'e': Shouter(supported_classes=(), available_actions=[], dotline_length=50, auto_output_type_selection=True, show_function=True, show_traceback=False, show_idx=False, tears_persist_path='log_records.json', env_persist_path='environment.dill', datetime_format='%Y-%m-%d %H:%M:%S', log_records=[], persist_env=False, lock=&lt;unlocked _thread.lock object at 0x7fa0dcf56600&gt;, last_traceback=[], log_plotter_h=None, log_plotter_class=&lt;class 'shouterlog.shouterlog.LogPlotter'&gt;, log_plotter_params={}, langfuse_h=None, langfuse_class=&lt;class 'shouterlog.shouterlog.LangfuseHandler'&gt;, langfuse_params={}, loggerLvl=20, logger_name=None, logger_format='%(levelname)s:%(name)s:%(message)s')}\n</code></pre>"},{"location":"description/#8-plotting-execution-flow-and-reviewing-steps","title":"8. Plotting execution flow and reviewing steps","text":"<p>The plotting feature turns recorded tracebacks into a sequence diagram, showing how execution moves between classes/functions over time. It uses <code>LogPlotter</code> to render lanes for each class and arrows for calls/events, making it easy to visualize flow from the collected log records.</p> <p>To use it, call <code>Shouter.show_sequence_diagram()</code> (or instantiate <code>LogPlotter</code> directly) with a list of log records such as <code>Shouter.return_logged_tears()</code>. You can customize labels, sizing, and proc grouping via the plotter parameters when calling the method.</p> <pre><code>import attrsx\n\n@attrsx.define(handler_specs={\n    \"example1\" : ExampleClass\n},\n    logger_chaining={\n    'logger' : True\n})\nclass MainExampleClass:\n\n    def __attrs_post_init__(self):\n\n        self._initialize_example1_h()\n\n    def print_example_print(self):\n\n        self.logger.debug(\"Printing from example!\", label = \"START\")\n\n        for i in range(5):\n\n            self.example1_h.print_debug()\n\n        self.logger.debug(\"Printing from example!\", label = \"END\")\n\n</code></pre> <pre><code>shouter_for_main_example_class = Shouter(\n    supported_classes = (MainExampleClass, ExampleClass,),\n    tears_persist_path = 'log_records2.json',\n    loggerLvl=logging.DEBUG\n)\n\nmec = MainExampleClass(logger=shouter_for_main_example_class)\n\nmec.print_example_print()\n</code></pre> <pre><code>DEBUG:Shouter:MainExampleClass.print_example_print:Printing from example!\nDEBUG:Shouter:ExampleClass.print_debug:+ This is a debug message!\nDEBUG:Shouter:ExampleClass.print_debug:+ This is a debug message!\nDEBUG:Shouter:ExampleClass.print_debug:+ This is a debug message!\nDEBUG:Shouter:ExampleClass.print_debug:+ This is a debug message!\nDEBUG:Shouter:ExampleClass.print_debug:+ This is a debug message!\nDEBUG:Shouter:MainExampleClass.print_example_print:Printing from example!\n</code></pre> <pre><code>mec.logger.show_sequence_diagram()\n</code></pre> <p></p> <pre><code>mec.logger.show_logs_by_id(ids = [1,2])\n</code></pre> <pre><code>[{'idx': 1,\n  'call_id': 140328889495328,\n  'datetime': '2026-01-28 00:38:48',\n  'level': 'debug',\n  'function': 'MainExampleClass.print_example_print',\n  'mess': 'Printing from example!',\n  'line': 17,\n  'lines': [17],\n  'is_proc': False,\n  'proc_name': 'Task-2',\n  'traceback': ['MainExampleClass.print_example_print'],\n  'label': 'START',\n  'env': {}},\n {'idx': 2,\n  'call_id': 104240187936336,\n  'datetime': '2026-01-28 00:38:48',\n  'level': 'debug',\n  'function': 'ExampleClass.print_debug',\n  'mess': 'This is a debug message!',\n  'line': 12,\n  'lines': [12, 21],\n  'is_proc': False,\n  'proc_name': 'Task-2',\n  'traceback': ['ExampleClass.print_debug',\n   'MainExampleClass.print_example_print'],\n  'label': None,\n  'env': {'a': 0}}]\n</code></pre>"},{"location":"description/#9-using-actions-from-logger","title":"9. Using actions from logger","text":"<p>Actions are post-log hooks that run after a log call. Each action is a named function with optional input validation and preprocessing that can merge the log record (\"tear\") with your parameters. This lets a log statement trigger side effects like emitting Langfuse traces, flushing buffers, or invoking custom handlers without changing your main logging flow.</p> <p>To add a new action, create a <code>LogAction</code> with a unique name, a callable, and optional <code>input_model</code>/<code>input_prep_func</code>, then pass it to <code>Shouter.add_actions([...])</code>. Default actions (like the Langfuse handler) are only registered if the handler has been initialized; once it is, calling <code>.add_actions()</code> will append those built-ins to <code>available_actions</code>, making them callable from logger methods.</p> <pre><code>import attrsx\n\n@attrsx.define\nclass ExampleClass2:\n\n\n    def print_debug(self):\n\n        a = 0\n\n        self.logger.debug(\"This is a debug message!\", save_vars = [\"a\"], actions = [{\n            \"name\" : \"langfuse.log_trace\",\n            \"params\" : {\n                \"input\" : {\"a\" : a}\n            }\n        }])\n\n@attrsx.define(handler_specs={\n    \"example1\" : ExampleClass2\n},\n    logger_chaining={\n    'logger' : True\n})\nclass MainExampleClass2:\n\n    def __attrs_post_init__(self):\n\n        self._initialize_example1_h()\n\n    def print_example_print(self):\n\n        self.logger.debug(\"Printing from example!\", label = \"START\", actions = [{\n            \"name\" : \"langfuse.log_trace\"\n        }])\n\n        for i in range(5):\n\n            self.example1_h.print_debug()\n\n        self.logger.debug(\"Printing from example!\", label = \"END\", actions = [{\n            \"name\" : \"langfuse.log_trace\"\n        }])\n\n</code></pre> <pre><code>from dotenv import load_dotenv\nload_dotenv(\"../../.langfuse.env\")\n\nshouter_with_langfuse = Shouter(\n    supported_classes = (MainExampleClass2, ExampleClass2,),\n    tears_persist_path = 'log_records2.json',\n    loggerLvl=logging.DEBUG\n)\n\nshouter_with_langfuse._initialize_langfuse_h(uparams = {\n    \"params\" : {\n        \"host\" : \"http://localhost:3000\"\n    },\n    \"env_mapping\" : {\n        \"secret_key\" : \"SECRET_KEY\",\n        \"public_key\" : \"PUBLIC_KEY\",\n    }\n})\n\nshouter_with_langfuse.add_actions()\n\nmec2 = MainExampleClass2(logger=shouter_with_langfuse)\n\nmec2.print_example_print()\n</code></pre> <pre><code>DEBUG:Shouter:MainExampleClass2.print_example_print:Printing from example!\nDEBUG:Shouter:ExampleClass2.print_debug:+ This is a debug message!\nDEBUG:Shouter:ExampleClass2.print_debug:+ This is a debug message!\nDEBUG:Shouter:ExampleClass2.print_debug:+ This is a debug message!\nDEBUG:Shouter:ExampleClass2.print_debug:+ This is a debug message!\nDEBUG:Shouter:ExampleClass2.print_debug:+ This is a debug message!\nDEBUG:Shouter:MainExampleClass2.print_example_print:Printing from example!\n</code></pre>"},{"location":"release-notes/","title":"Release notes","text":""},{"location":"release-notes/#031","title":"0.3.1","text":"<pre><code>- actions hook support\n\n- initial langfuse default actions in shouter\n</code></pre>"},{"location":"release-notes/#030","title":"0.3.0","text":""},{"location":"release-notes/#020","title":"0.2.0","text":"<pre><code>- initial support for log plotting of sequence-like visualization\n</code></pre>"},{"location":"release-notes/#010","title":"0.1.0","text":"<pre><code>- initial version of the package with traceback\n</code></pre>"}]}